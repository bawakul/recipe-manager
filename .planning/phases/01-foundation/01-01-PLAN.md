---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - wrangler.toml
  - tsconfig.json
  - .gitignore
  - .dev.vars.example
  - src/types.ts
  - src/claude.ts
  - src/index.ts
autonomous: true
user_setup:
  - service: anthropic
    why: "Claude API for recipe parsing"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "https://console.anthropic.com/settings/keys -> Create Key"
  - service: cloudflare
    why: "Workers deployment"
    env_vars: []
    dashboard_config:
      - task: "Create free Cloudflare account if needed"
        location: "https://dash.cloudflare.com/sign-up"

must_haves:
  truths:
    - "User can POST transcript text to /api/recipe/parse"
    - "Response contains valid JSON with recipe structure"
    - "Recipe includes title, sections, steps with IDs, and ingredients"
    - "Parser handles filler words and self-corrections gracefully"
  artifacts:
    - path: "src/index.ts"
      provides: "Worker fetch handler with CORS"
      exports: ["default"]
    - path: "src/types.ts"
      provides: "Zod schema and TypeScript types"
      exports: ["RecipeSchema", "Recipe", "Section", "Step", "Ingredient"]
    - path: "src/claude.ts"
      provides: "Claude API client wrapper"
      exports: ["parseTranscript"]
    - path: "wrangler.toml"
      provides: "Worker configuration"
      contains: "name = \"recipe-parser\""
  key_links:
    - from: "src/index.ts"
      to: "src/claude.ts"
      via: "import parseTranscript"
      pattern: "import.*parseTranscript.*from.*claude"
    - from: "src/claude.ts"
      to: "@anthropic-ai/sdk"
      via: "SDK client initialization"
      pattern: "new Anthropic"
    - from: "src/claude.ts"
      to: "src/types.ts"
      via: "Zod schema for structured outputs"
      pattern: "betaZodOutputFormat.*RecipeSchema"
---

<objective>
Set up complete Cloudflare Worker with Claude API integration for parsing voice transcripts into structured recipes.

Purpose: This is the core API that all other phases depend on. Establishes the foundation for the entire recipe checklist system.

Output: A deployable Cloudflare Worker that accepts POST requests with transcript text and returns structured recipe JSON using Claude's structured outputs feature.
</objective>

<execution_context>
@/Users/bharadwajkulkarni/.claude/get-shit-done/workflows/execute-plan.md
@/Users/bharadwajkulkarni/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Cloudflare Worker project</name>
  <files>package.json, wrangler.toml, tsconfig.json, .gitignore, .dev.vars.example</files>
  <action>
Create the Worker project structure:

1. Create `package.json` with:
   - name: "recipe-parser"
   - type: "module"
   - scripts: { "dev": "wrangler dev", "deploy": "wrangler deploy", "test": "echo 'no tests yet'" }
   - dependencies: @anthropic-ai/sdk, zod
   - devDependencies: wrangler, typescript, @cloudflare/workers-types

2. Create `wrangler.toml` with:
   - name = "recipe-parser"
   - main = "src/index.ts"
   - compatibility_date = "2026-01-28"
   - [env.staging] with name = "recipe-parser-staging"

3. Create `tsconfig.json` with:
   - target: "ES2022"
   - module: "ESNext"
   - moduleResolution: "bundler"
   - strict: true
   - types: ["@cloudflare/workers-types"]
   - include: ["src/**/*"]

4. Add to `.gitignore`:
   - node_modules/
   - .dev.vars
   - .wrangler/
   - dist/

5. Create `.dev.vars.example` as template:
   - ANTHROPIC_API_KEY="sk-ant-your-key-here"

Then run `npm install` to install dependencies.
  </action>
  <verify>
    - `ls package.json wrangler.toml tsconfig.json .gitignore .dev.vars.example` shows all files exist
    - `npm ls @anthropic-ai/sdk zod wrangler` shows dependencies installed
    - `cat .gitignore | grep .dev.vars` confirms secrets are gitignored
  </verify>
  <done>
    - package.json exists with correct dependencies
    - wrangler.toml configured for TypeScript Worker
    - TypeScript strict mode enabled
    - .dev.vars gitignored to prevent secret leaks
    - Dependencies installed via npm
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod schema and types</name>
  <files>src/types.ts</files>
  <action>
Create `src/types.ts` defining the recipe data structure:

```typescript
import { z } from 'zod';

// Step in a recipe section
export const StepSchema = z.object({
  id: z.string().describe('Unique step ID like "step-1"'),
  text: z.string().describe('The instruction text'),
  completed: z.boolean().default(false)
});

// Ingredient with optional quantity
export const IngredientSchema = z.object({
  name: z.string().describe('Ingredient name'),
  quantity: z.string().optional().describe('Amount needed'),
  notes: z.string().optional().describe('Prep notes like "diced" or "room temperature"')
});

// Section of a recipe (Prep, Marinate, Cook, Assemble)
export const SectionSchema = z.object({
  name: z.enum(['Prep', 'Marinate', 'Cook', 'Assemble']).describe('Section type'),
  steps: z.array(StepSchema).describe('Steps in this section')
});

// Complete recipe structure
export const RecipeSchema = z.object({
  title: z.string().describe('Recipe name derived from transcript'),
  sections: z.array(SectionSchema).describe('Recipe sections in execution order'),
  ingredients: z.array(IngredientSchema).describe('All ingredients extracted from transcript')
});

// TypeScript types derived from Zod schemas
export type Step = z.infer<typeof StepSchema>;
export type Ingredient = z.infer<typeof IngredientSchema>;
export type Section = z.infer<typeof SectionSchema>;
export type Recipe = z.infer<typeof RecipeSchema>;

// Worker environment type
export interface Env {
  ANTHROPIC_API_KEY: string;
}
```

The schema matches requirements (API-03): sections with Prep/Marinate/Cook/Assemble, steps with IDs, extracted ingredients.
  </action>
  <verify>
    - `npx tsc --noEmit` completes without errors
    - Types are exported: Recipe, Section, Step, Ingredient, Env
    - RecipeSchema is exported for Claude integration
  </verify>
  <done>
    - Zod schemas define recipe structure with proper descriptions for Claude
    - TypeScript types derived from schemas (single source of truth)
    - Env interface declares ANTHROPIC_API_KEY
    - Section enum includes Prep, Marinate, Cook, Assemble per requirements
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Claude API client with structured outputs</name>
  <files>src/claude.ts</files>
  <action>
Create `src/claude.ts` with Claude API integration:

```typescript
import Anthropic from '@anthropic-ai/sdk';
import { betaZodOutputFormat } from '@anthropic-ai/sdk/helpers/beta/zod';
import { RecipeSchema, Recipe, Env } from './types';

const SYSTEM_PROMPT = `You are a recipe parser. Extract structured recipe data from rambling voice transcripts.

Handle gracefully:
- Filler words (um, uh, like, you know)
- Self-corrections (no wait, actually, I mean)
- Non-linear ordering (ingredients mentioned mid-step)
- Transcription errors (use context to infer correct words)
- Incomplete thoughts (fill in reasonable defaults)

Extract sections in order: Prep (if applicable), Marinate (if applicable), Cook, Assemble (if applicable).
Not every recipe needs all sections - only include what's relevant.
Generate sequential step IDs (step-1, step-2, etc.) across all sections.
Extract ALL ingredients mentioned, even if scattered throughout the transcript.`;

export async function parseTranscript(
  transcript: string,
  env: Env
): Promise<Recipe> {
  const client = new Anthropic({ apiKey: env.ANTHROPIC_API_KEY });

  const response = await client.beta.messages.parse({
    model: 'claude-sonnet-4-5',
    max_tokens: 4096,
    betas: ['structured-outputs-2025-11-13'],
    system: SYSTEM_PROMPT,
    messages: [{
      role: 'user',
      content: `<transcript>${transcript}</transcript>`
    }],
    output_format: betaZodOutputFormat(RecipeSchema)
  });

  // Check for max_tokens cutoff
  if (response.stop_reason === 'max_tokens') {
    throw new Error('Recipe too complex or transcript too long');
  }

  // parsed_output is typed as Recipe thanks to Zod
  return response.parsed_output;
}
```

Key implementation details:
- Uses `client.beta.messages.parse` for structured outputs (NOT regular messages.create)
- Uses `betaZodOutputFormat` to convert Zod schema to Claude format
- System prompt addresses API-02 requirements (filler words, corrections, errors, non-linear ordering)
- max_tokens set to 4096 per research recommendations
- Throws on max_tokens cutoff for proper error handling
  </action>
  <verify>
    - `npx tsc --noEmit` completes without errors
    - parseTranscript function exported
    - System prompt includes handling for filler words, corrections, transcription errors
  </verify>
  <done>
    - Claude client configured with structured outputs beta
    - System prompt handles rambling input per API-02
    - parseTranscript returns typed Recipe object
    - Error thrown on max_tokens cutoff
  </done>
</task>

<task type="auto">
  <name>Task 4: Create Worker fetch handler</name>
  <files>src/index.ts</files>
  <action>
Create `src/index.ts` as the Worker entry point:

```typescript
import { parseTranscript } from './claude';
import { Env } from './types';

// CORS headers for web app integration
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    // Handle CORS preflight
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    // Route: POST /api/recipe/parse
    if (url.pathname === '/api/recipe/parse' && request.method === 'POST') {
      return handleParse(request, env);
    }

    // 404 for unknown routes
    return new Response(
      JSON.stringify({ error: 'Not found' }),
      { status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
};

async function handleParse(request: Request, env: Env): Promise<Response> {
  try {
    // Parse request body
    const body = await request.json() as { transcript?: string };

    if (!body.transcript || typeof body.transcript !== 'string') {
      return new Response(
        JSON.stringify({ error: 'Invalid request: transcript required' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (body.transcript.length < 10) {
      return new Response(
        JSON.stringify({ error: 'Transcript too short' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Parse transcript with Claude
    const recipe = await parseTranscript(body.transcript, env);

    return new Response(JSON.stringify(recipe), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('Error parsing recipe:', error);

    // Check for rate limit errors
    if (error instanceof Error && error.message.includes('429')) {
      return new Response(
        JSON.stringify({ error: 'Rate limit exceeded. Please try again in a moment.' }),
        { status: 429, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Check for transcript too long
    if (error instanceof Error && error.message.includes('too complex')) {
      return new Response(
        JSON.stringify({ error: error.message }),
        { status: 413, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    return new Response(
      JSON.stringify({ error: 'Failed to parse recipe. Please try again.' }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
}
```

Implementation notes:
- CORS enabled for web app integration (Phase 2)
- Validates transcript exists and has minimum length
- Proper error responses for 400, 413, 429, 500 cases
- Route structure allows future endpoint additions
  </action>
  <verify>
    - `npx tsc --noEmit` completes without errors
    - `npx wrangler dev` starts without errors (will fail on API calls without key, but should start)
    - Worker responds to OPTIONS with CORS headers
    - Worker returns 404 for unknown routes
  </verify>
  <done>
    - Worker exports default fetch handler
    - POST /api/recipe/parse endpoint accepts transcript
    - CORS headers allow cross-origin requests
    - Proper HTTP status codes: 200, 400, 404, 413, 429, 500
    - Request validation for missing/short transcript
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript compiles:** `npx tsc --noEmit` exits 0
2. **Worker starts:** `npx wrangler dev` launches dev server (port 8787)
3. **Route responds:** `curl -X OPTIONS http://localhost:8787/api/recipe/parse` returns CORS headers
4. **Validation works:** `curl -X POST http://localhost:8787/api/recipe/parse -H "Content-Type: application/json" -d '{}'` returns 400 error
5. **Structure correct:** All files exist in expected locations

Full end-to-end test requires ANTHROPIC_API_KEY in .dev.vars - this is covered by user_setup.
</verification>

<success_criteria>
Phase 1 Foundation is complete when:
- [x] Cloudflare Worker project initialized with all dependencies
- [x] Zod schema defines Recipe structure with sections, steps, ingredients
- [x] Claude client uses structured outputs beta with rambling-input system prompt
- [x] Worker exposes POST /api/recipe/parse with proper validation and error handling
- [x] TypeScript compiles without errors
- [x] Worker starts in dev mode

Requirements satisfied:
- API-01: POST /api/recipe/parse accepts transcript and returns JSON
- API-02: System prompt handles filler words, corrections, errors, non-linear ordering
- API-03: Output includes sections (Prep/Marinate/Cook/Assemble), steps with IDs, ingredients
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md` using the summary template.
</output>
